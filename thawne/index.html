<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Thawne</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
    <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>
    <script async src="js/opencv.js" onload="openCvReady();"></script>
    <script src="js/utils.js"></script>
    <script src="/path/to/flash.min.js"></script>
  </head>
  <body class="bg-zinc-800">
    <div id="root" class="w-full flex-1">
    </div>
    <div className="bg-white">
      <video id="cam_input" hidden height="240" width="320"></video>
      <canvas id="canvas_output"  ></canvas>
      <h1 id="statusText"  ></h1>
    </div>

    <script type="module" src="src/main.jsx"></script>
    <script type="text/JavaScript">

      let dialogShown = false;
      
      function openCvReady() {

        

        cv['onRuntimeInitialized']=()=>{
          let video = document.getElementById("cam_input"); // video is the id of video tag
          navigator.mediaDevices.getUserMedia({ video: true, audio: false })
          .then(function(stream) {
              video.srcObject = stream;
              video.play();
          })
          .catch(function(err) {
              console.log("An error occurred! " + err);
          });
          let src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
          let dst = new cv.Mat(video.height, video.width, cv.CV_8UC1);
          let gray = new cv.Mat();
          let cap = new cv.VideoCapture(cam_input);
          let faces = new cv.RectVector();
          let classifier = new cv.CascadeClassifier();
          let utils = new Utils('errorMessage');
          let faceCascadeFile = 'haarcascade_frontalface_default.xml'; // path to xml
          utils.createFileFromUrl(faceCascadeFile, faceCascadeFile, () => {
          classifier.load(faceCascadeFile); // in the callback, load the cascade from file
      });
          const FPS = 24;

          let lastCountOfMoreThanOneFace = 0

          let safe_mode = true;


          let current_time = Date.now()
          let element = document.getElementById('canvas_output');
          //if (safe_mode == true){
            //element.style.border = '10px solid lightgreen';
          //}

          electron.onUpdateCounter((value) => {
            safe_mode = false;
            current_time = Date.now()
          })

          function showDialog() {
            if (!dialogShown) {
                electron.showDialog();
                dialogShown = true;
        
                setTimeout(() => {
                    dialogShown = false;
                    setTimeout(showDialog, 3000000);
                }, 3000000); 
            }
        }
        

          function processVideo() {
              let begin = Date.now();
              if (safe_mode == false) {
                element.style.border = '10px solid red';
                
                //console.log("entered");
                if (Date.now()-current_time > 30000) {
                  

                  safe_mode = true;


                }
              }
              else{
                element.style.border = '10px solid lightgreen';
              }

              //console.log(begin);
              cap.read(src);
              src.copyTo(dst);
              cv.cvtColor(dst, gray, cv.COLOR_RGBA2GRAY, 0);
              gray.copyTo(dst)
              try{
                  classifier.detectMultiScale(gray, faces, 1.1, 3, 0);
                  
              }catch(err){
                  console.log(err);
              }

              let statusText = document.getElementById("statusText");
              if (faces.size() > 1) {
                  lastCountOfMoreThanOneFace = lastCountOfMoreThanOneFace + 1

              } else {
                  lastCountOfMoreThanOneFace = 0
              }

              if (lastCountOfMoreThanOneFace > 1 && safe_mode === true) {
                statusText.innerHTML = 'Fuck off!'
                showDialog()

              }
              else {
                  statusText.innerHTML = 'I love you!'
              }


              for (let i = 0; i < faces.size(); ++i) {
                  let face = faces.get(i);
                  let point1 = new cv.Point(face.x, face.y);
                  let point2 = new cv.Point(face.x + face.width, face.y + face.height);
                  cv.rectangle(dst, point1, point2, [255, 0, 0, 255]);
              }
              cv.imshow("canvas_output", dst);
              // schedule next one.
              let delay = 1000/FPS - (Date.now() - begin);
              setTimeout(processVideo, delay);
      }
      // schedule first one.
      setTimeout(processVideo, 0);
        };
      }
</script>

  </body>
</html>
